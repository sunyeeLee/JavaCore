#### 1. 如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？
    
问题的备选答案，按照这一课里的内容，是个二选一的问题：分析器阶段，还是执行器阶段。这两个阶段做的事：

问题解决思路: 首先创建2张表: a和b表， 然后创建用户user_test。赋予user_test a表的权限，b表无权限.

SELECT a1 FROM a;
```
 Error for unknown column
```
SELECT a2 FROM a;
```
 Error for unknown column
```
SELECT b1 FROM b;
SELECT b2 FROM b;
```
    ERROR 1142 (42000): SELECT command denied to user 'user_test'@'localhost' for table 'b'
```

对于后2行无权限的直接报该用户没有没有该表的权限。而前2行查询a表报的是没有该列。且用户是否拥有表的
权限是在执行期开始的时候校验的。如果没有权限，则报权限错误，否则，则打开该表，通过存储引擎提供的接口
，对表进行操作。这样的话，就可以知道获知某个表是否存在某个列，是需要打开一个表后才能知道该列是否存在的
。这样分析后，整个逻辑链条就清晰了。所以是执行期阶段报出的错误。

#### 一个 SQL 执行的很慢，我们要分两种情况讨论：

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。


#### 怎么删除表的前 10000 行。
    即:在一个连接中循环执行 20 次 delete from T limit 500。在同一个连接中，事务的执行是线性的。因此不会造成锁冲突。


#### 唯一索引与普通索引区别
    唯一索引不使用change buffer, 普通索引使用change buffer
    这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下:
        对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结 束;
        对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。
        
        
#### redo log的作用
    redo log(重做日志)，保证数据库有cash-safe能力，就是挂了重启能及时恢复数据。属于inno db引擎。
    一般和bin log配合，保证内存和磁盘数据一致，事务变更时，采用两阶段提交策略保证。