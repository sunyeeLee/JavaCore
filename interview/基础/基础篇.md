#### List、Set和Map的区别与联系？
    1。List(列表)和Set(集合)都继承与Collection接口，其中List是可重复、有序集合。Set是不可重复、无序集合
    2。Map(散列表)是维护了键对象和值对象的映射关系的容器。Map中存储的元素是无序的，并且key是不可重复的。
    3。List接口实现一般有ArrayList(基于数组实现，索引快)、Vector(基于数据实现，索引快并且但部分方法是同步的)
        和LinkedList(基于队列实现，数据更改数独快，索引慢)
    4。Set接口实现一般有HashSet(基于HashMap实现，无序)、LinkedHashSet(基于LinkedHashMap，有序，维护了插入顺序)
        和TreeSet(基于TreeMap, 有序，存储元素的升序)
    5。Map接口实现一般有HashMap、LinkedHashMap、TreeMap和HashTable。其中HashTable是线程安全的，大部分
        方法都是同步的。Hash的底层实现是数组+红黑树，LinkedHashMap在HashMap的基础上多维护了元素的插入顺序，是基于队列实现的。
        TreeMap是基于红黑树实现的，维护了元素的自然升序。
        
        
#### 为什么List, Set, Map没有实现Clone和Serializable接口？
    List,Set,Map都是抽象类或者接口，本身只负责定义接口方法，而如何存储和维护这些对象应该由具体的实现决定。
    
    如何存储和维护这些对象是由具体实现来决定的。
    因为集合的具体形式多种多样，例如list允许重复，set则不允许。而克隆（clone）和
    序列化（serializable）只对于具体的实体，对象有意义，你不能说去把一个接口，抽象类克隆，
    序列化甚至反序列化。所以具体的collection实现类是否可以克隆，是否可以序列化应该由其自身决定，
    而不能由其超类强行赋予。 
    
#### 什么时候使用HashMap? HashMap为什么不安全
    当需要一种数据结构提供映射关系时. 
    
    1.7 HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，
    这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，
    如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。
    
    1.8 修复了闭环，但是HashMap在添加数据的时候，如果不加锁。会发生数据覆盖的情况。
    
#### ConcurrentHashMap的实现， 1.7和1.8的实现。put()方法
       ConcurrentHashMap1.7底层实现为数组+链表, 采用分段锁的形式进行同步.如果链表很长，会使得
       查找数据的时间复杂度为O(n).
       
       1.8底层实现为数组+链表+红黑树，当链表的数量大于8的时候，
       转换为红黑树，采用synchronized + cas方式来实现同步。采用红黑树的话时间复杂度变成O(lgN)
   
    put的过程很清晰，对当前的table进行无条件自循环直到put成功，可以分成以下六步流程来概述
    
    1。 如果没有初始化就先调用initTable（）方法来进行初始化过程
    2。 如果没有hash冲突就直接CAS插入
    3。 如果还在进行扩容操作就先进行扩容
    4。 如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，
    5。 最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环(阿里面试官问题，默认的链表大小，超过了这个值就会转换为红黑树);
    6。 如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容
    
    
#### 什么是CopyOnWriteArrayList？
    Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，
    才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,
    它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。
    
    CopyOnWriteArrayList相当于线程安全的ArrayList，CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素add到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，
    然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。
    
    这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
    
    注意：CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的。也就是说add方法是线程安全的。
    
    CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。
    
    和ArrayList不同的是，它具有以下特性：
    
    支持高效率并发且是线程安全的 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作
     使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照
     
#### 什么时候使用CopyOnWriteArrayList?
    CopyOnWriteArrayList是线程安全、写时复制的容器。当往容器新增一个元素时，不是直接添加元素，而是先
    在旧的容器的基础上复制一个新的数组容器，然后往新容器内添加元素，完成之后返回新数组容器。这样做的好处是
    读的时候不需要加锁，因为当前数组的元素是不变的。体现了读写分离的思想。
    因此该容器适合的场景是读多写少的情况.
    
    
#### volatile的使用?
    volatile提供了一种轻量级的同步机制，被volatile修饰的变量是线程可见的，有序性(不会被重排序)。
    但是不能保证原子性。
   
   
### synchronized的使用？
    造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。
    因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且
    只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，
    即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，
    其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。
    
    在Java中，关键字synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个
    代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个
    重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到
    （保证可见性，完全可以替代Volatile功能）

    1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
    
    2. 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
    
    3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
    
    
    Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式
    同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。
    
    
#### ReentrantLock的实现和synchronized的区别？
    synchronzied属于隐式锁，锁的持有和释放都是隐式的，不需要认为干预。ReentrantLock属于显示锁，
    锁的持有和释放都需要显示编写。两者都是可重入锁，但是ReentrantLock特性更丰富，ReentrantLock同时
    也支持公平锁和非公平锁、如可中断锁的获取(synchronized在等待获取锁时是不可中的)，超时中断锁的获取，
    等待唤醒机制的多条件变量Condition等，这也使得Lock锁在使用上具有更大的灵活性.
    
    ReentrantLock是基于AQS(AbstractQueueSynchronizer，同步队列器)实现的.
    
    
#### AQS的实现原理?
    AbstractQueueSynchronizer又称同步队列器, 简称AQS。它是用来构建锁或者其他同步器(Semphore、栅栏)的
    基础框架。其内部通过一个int类型变量state来控制同步状态,当state为0时，说明没有任何线程占有共享资源的锁，
    当state为1时，则说明有线程占有共享变量的锁,其他线程必须加入同步队列进行等待，AQS内部通过内部类
    Node构成FIFO的同步队列来完成线程获取锁的排队工作，同时利用内部类ConditionObject构成等待队列，
    当Condition调用wait()方法后，线程会进入等待队列。而当Condition调用signal()方法后，
    线程将从等待队列转移动同步队列中进行锁竞争。
    
    
    注意这里涉及到两种队列，一种的同步队列，当线程请求锁而等待的后将加入同步队列等待，
    而另一种则是等待队列(可有多个)，通过Condition调用await()方法释放锁后，将加入等待队列。
    
#### 什么是线程、进程？
    进程（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的
    系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统
    （如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。
    
    线程(Thread)是进程内的执行单元。使用线程的原因是进程的切换是非常重量级的操作，非常消耗资源。
#### 死锁产生的四大条件？
    互斥条件： 临界区资源一次只允许一个线程访问，其他线程只能等待。
    
    资源不剥夺条件： 一个线程若占有了临界区资源，其他线程不能剥夺该线程占有的资源
    
    请求与保持条件： 一个线程占有了A资源的同时，去请求B资源。而B资源被其他线程占有
    
    循环等待条件： 存在一个循环等待的链，链中每个线程占有的资源都被链中下一个进程所占有
        
    但是死锁虽说是不好的现象，但是它是一个静态的问题，一旦发生死锁，进程被卡死，cpu占有率也是0，它不会占用cpu
    
#### 什么是活锁？
    活锁，指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。
    
    举个例子，就如同你在街上遇到个人，刚好他朝着你的反方向走，与你正面碰到，你们都想让彼此过去。你往左边移，他也往左边移，
    两人还是无法过去。这时你往右边移，他也往右边移，如此循环下去。
    
    一个线程在取得了一个资源时，发现其他线程也想到这个资源，因为没有得到所有的资源，为了避免死锁把自己持有的资源
    都放弃掉。如果另外一个线程也做了同样的事情，他们需要相同的资源，比如A持有a资源，B持有b资源，放弃了资源以后，
    A又获得了b资源，B又获得了a资源，如此反复，则发生了活锁。
   
    
#### CAS的实现原理以及问题?
    CAS提供了一种无锁，非阻塞的线程安全的算法。
    CAS算法核心是比较并交换，有3个参数，内存值V，预期值E，新值N。当且仅当E==N时，将V更新为N，否则什么也不做。
    
    底层通过利用CPU的CAS指令对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作
    
    缺点：
        但是有可能发生内存值原来是A，中间被改成B，后来又被改成A，此时再使用CAS进行检查时发现没有变化，
        但是实际上发生了变化，这就是ABA问题。
        
        Java并发包下的AtomicStampedReference可以解决ABA问题，内部实现上添加了一个类似于版本号
        作用的stamp属性，它是被自动更新的。实现上首先检查当前引用是否等于预期引用、当前stamp是否
        等于预期stamp，如果全部相等，则以原子方式将该引用和该stamp的值设置为给定的更新值。
    
#### 在JVM中表示两个class对象是否为同一个类对象存在两个必要条件
     1。类的完整类名必须一致，包括包名
     2。加载子该类的的ClassLoader(ClassLoader的实例对象)必须相同。
    
#### 类加载机制的步骤，每一步做了什么，static和final修饰的成员变量的加载时机？
    类的加载步骤主要是：
        加载：通过类的全名查找类的字节码文件，并利用字节码文件创建一个Class对象
        链接：
            验证：确保此Class文件的字节流符合JVM的安全规范，验证：文件格式、元数据、字节码、符号引用的验证
            准备：为类变量(static)分配内存并设置默认值，其中static和final修饰的变量为编译时常量
                在编译阶段就已经完成初始化。类变量分配在方法区，实例变量跟随对象分配到堆内存
            解析：符号引用解析为直接引用。符号引用就是用来描述目标变量的，而直接引用就是直接指向目标的指针
        初始化： 类加载最后的阶段。
              1。如果该类含有超类，初始化超类的静态变量和静态代码块
              2。初始化子类的静态变量和静态代码块
              3。初始化超类的成员变量和构造函数
              4。初始化子类的成员变量和构造函数
              
              
    注意：
        判断一个对象是否相同是由同一个类和类加载器共同决定的。
        
        
#### 类加载模型，以及如何自定义类加载器？
    类加载器主要由：
        启动类加载器(Bootstrap Classloader)：
            启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，
            它负责加载 <JAVA_HOME>/lib路径下的核心类库
        
        扩展类加载器(Extension Classloader):
            扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，
            由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录
        
        系统类加载器(Application Classloader):
            应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载
            系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的
            classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，
            通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器
            
#### 什么是双亲委派模型？
    双亲委派模型表示：如果一个类加载器收到了类加载请求，首先它并不会自己去加载，而是将请求委托给父加载器执行，如果
    父类加载器还存在其父类加载器，则进一步委托。最终到达顶层的启动类加载器(Bootstrap Classloader)，如果父类加载器
    可以完成类加载任务，则成功返回。只有父类不能完成该类的加载请求，子类才会去加载该类。
    
#### 双亲委派模型的好处？
    双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关
    可以避免类的重复加载，当父加载器已经加载了该类时，就没有必要子ClassLoader再加载一次。
    其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer
    的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载
    ，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，
    这样便可以防止核心API库被随意篡改。
    
#### 反射机制：反射动态擦除泛型、反射动态调用方法等？
    反射机制是一种提供运行时获取类信息的机制.在程序运行阶段，对于任意一个类，我们都可以知道该类的方法和属性；
        对于任意一个对象，我们都可以调用它的方法和属性。
    
    泛型擦除：泛型是1.5引入的新特性，可以使得利用泛型来表示Class对象更具体的类型。但是在运行期间类型会被擦除，
        虽然如此，但是编译器可以确保我们在编译阶段使用了正确的对象类型.
    
    
#### 获取Class对象引用的方式有那些？有什么区别？
    在Java中用来表示运行时类型信息的对应类就是Class类，它包含了与类有关的信息，Class类也是一个实实在在的类，
    存在于JDK的java.lang包中
    
    获取Class对象引用的方式有三种：
        1。继承自Object类的getClass()方法
        2。Class的静态方法forName()方法
        3。类字面常量".class"
        
    其中getClass()和forName()会触发类的初始化，而类字面常量".class"方式不会触发类的初始化
    
    
#### 关于类加载的初始化阶段，在虚拟机规范严格规定了有且只有5种场景必须对类进行初始化
    1.使用new关键字实例化对象时、读取或者设置一个类的静态字段(不包含编译期常量)以及调用静态方法的时候，
        必须触发类加载的初始化过程(类加载过程最终阶段)。
    
    2.使用反射包(java.lang.reflect)的方法对类进行反射调用时，如果类还没有被初始化，则需先进行初始化，这点对反射很重要。
    
    3.当初始化一个类的时候，如果其父类还没进行初始化则需先触发其父类的初始化。
    
    4.当Java虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的类)，虚拟机会先初始化这个主类
    
    5.当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后解析结果
        为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应类没有初始化时，
        必须触发其初始化(


#### 动态绑定：父类引用指向子类对象？
    绑定：将调用的方法和方法所在的类(方法的主体对象)关联起来。
    
    在java中： 绑定分为静态绑定和动态绑定。也叫前期绑定和后期绑定.
    
    静态绑定：在程序执行以前就已经被绑定了，即在编译阶段就知道调用哪个类的方法了。
        java当中的方法只有final、static、private修饰的的方法和构造方法是静态绑定的。
    
    动态绑定：在运行时期根据具体对象的类型进行绑定。
        若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。
        也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。
        不同的语言对后期绑定的实现方法是有所区别的，但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。
        
        动态绑定的过程：
        
        1.虚拟机提取对象实际类型的方法表
        
        2.虚拟机搜索方法签名
        
        3.调用方法
        
        根据对象(father)的声明类型(Father)还不能够确定调用方法f1的位置，必须根据father在堆中实际创建的
        对象类型Son来确定f1方法所在的位置。这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，
        我们叫做 动态绑定机制 。
    java中重载的方法使用静态绑定，重写的方法使用动态绑定。
    
    ```
        //被调用的父类
        class Father{
            public void f1(){
                System.out.println("father-f1()");
            }
                public void f1(int i){
                        System.out.println("father-f1()  para-int "+i);
                }
        }
        //被调用的子类
        class Son extends Father{
            public void f1(){ //覆盖父类的方法
                System.out.println("Son-f1()");
            }
                public void f1(char c){
                        System.out.println("Son-s1() para-char "+c);
                }
        }
        
        //调用方法
        import hr.test.*;
        public class AutoCall{
            public static void main(String[] args){
                Father father=new Son(); //多态
                father.f1(); //打印结果： Son-f1()
            }
        }
    ```
    上面的源代码中有三个重要的概念：多态(polymorphism) 、方法覆盖 、方法重载 。打印的结果大家也都比较清楚，
    但是JVM是如何知道f.f1()调用的是子类Sun中方法而不是Father中的方法呢？在解释这个问题之前，
    我们首先简单的讲下JVM管理的一个非常重要的数据结构——方法表 。
    
    在JVM加载类的同时，会在方法区中为这个类存放很多信息(详见《Java 虚拟机体系结构 》)。其中就有一个数据结构
    叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址 。
    下图是上面源代码中Father和Sun类在方法区中的方法表：
    
    下图中的方法表有两个特点：(1) 子类方法表中继承了父类的方法，比如Father extends Object。 
        (2) 相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()
        和Son方法表中的f1()都位于各自方法表的第11项中。
![](/Users/lishunyi/Documents/sass现金贷/对接服务/新颜/风险评估/JAVA/JavaCore/src/main/resources/package/动态绑定.jpg)
     
    
    
#### JVM内存管理机制：有哪些区域，每个区域做了什么？
    java vitural machine主要包括堆、方法区、程序计数器、虚拟机栈、本地方法栈。
    其中堆和方法区是线程共有的。其他均为线程私有的.
    
    程序计数器：线程私有的，保存着该线程下一条需要执行的指令。
            当线程数量超过CPU数量时，线程之间通过时间片轮询抢夺CPU资源，对于单个CPU而言，一个段时间内只有
            一个线程运行，其他线程必须被切换出去。因此，每个线程都必须又一个独立的程序计数器，用以保存下一条
            要运行的指令。
    
    虚拟机栈：线程私有的，保存这方法变量、部分返回结果、参与方法的调用与返回。
        Java栈的大小分为固定和动态的。在Java虚拟机规范中，有2种异常与栈有关：StackOverFlowError和OutOfMemoryError。
        如果线程在运行过程种，请求栈的深度大于最大可用深度的话，就会跑出StackOverFlowError；如果栈是动态扩展的，
        而在扩展的过程中，发现内存没有多余的空间的话，则跑出OutOfMemoryError。
        
        我们通常使用参数-Xss来设置栈的大小，该值决定了函数调用的最大可达深度。
        
        
        虚拟机栈使用了一种叫栈帧的数据结构保存上下文数据。在栈帧中，存放了方法的局部变量、操作数栈、动态链接方法、
        返回地址等信息。每个方法的调用都对应着栈帧的入栈操作，相应地，每个方法的返回对应着栈帧的出栈操作。
        
        如果方法调用时，方法的参数和局部变量相对较多的话，那么栈帧的局部变量表就会变大，栈帧也会膨胀。因此单个方法
        调用所需的栈空间大小也会比较多，调用的最大可达深度也会相应减少。
        
        因此在虚拟机栈中，于性能调优关系最大的就是局部变量表。
        
        
    本地方法栈：线程私有的。作用于虚拟机栈类似，Java虚拟机栈管理Java函数的调用，而本地方法栈管理本地方法的调用。
        同时，它也会抛出StackOverFlowError和OutOfMemoryError。
        
    
    Java堆：线程共有的。Java堆可以说运行时内存中最重要的一部分，几乎所有的对象的数组都是在堆上分配内存空间的。
        Java堆分为新生代和老年代。新生代保存着刚产生的对象和年轻的对象；如果对象一直没被回收，存活的足够长，就会
        被移到老年代。(周期一般为15次mirror gc)
        
        新生代又可进一步分为eden区域和surrior区域，其中surrior区域分为from space, to space区域。eden意义为
        伊甸园，意味着对象的出生地。大部分对象刚建立时，通常会存放在这里。from space和to space空间，为幸存者，
        这里的对象至少经历了一次垃圾回收，并且得以存活。如果在幸存区的对象到了指定年龄仍未被回收，则会进入到
        老年代tenured。
        
        
    方法区：线程共有的，同样也是java内存中非常重要的一块内存区域。方法区主要保存的是类的元数据、常量池、静态变量等信息。
        类型信息包括类的完整名称、父类的完整名称、类型修饰符和类型的直接接口类表。
        常量池包括这个类方法、域等信息所引用的常量信息。域信息包括域名称、类型和修饰符等；
        方法信息包括方法名称、返回类型、方法参数、方法修饰符等
            
        
        通常使用"-XX:PermSize"参数来设置该区域的值
        
        
        
#### JVM内存参数配置
    JVM内存参数一般分为设置堆大小、设置新生代大小、设置持久代大小、设置虚拟机栈大小等。
    
    最大堆内存分配：
        一般使用"-Xmx"来设置最大堆的大小。最大堆指的是新生代和老年代的大小之和的最大值。它是java堆内存的上限值
        
        
    最小堆内存分配：
        一般使用"-Xms"来设置最小堆的大小空间。最小堆指的是JVM启动时，所占据的操作系统内存的大小。Java程序运行时，
        首先会先分配-Xms指定的内存大小，并尽可能在这个空间大小运行程序。如果指定的内存不能满足程序时，JVM会向
        操作系统申请更多的内存空间，直到达到最大堆(-Xmx)的大小为止，若超过则跑出OutOfMemoryError异常。
        
        如果-Xms指定过小，程序为了尽可能在这范围内运行，会频繁的进行GC操作。因此，过小会增加GC次数，对性能产生
        一定的影响。
        
        
    设置新生代：
        一般使用"-Xmn"来设置新生代的大小。设置较大的新生代会减小老年代的大小；该参数对系统的性能有很大的影响，
        新生代的大小一般设置为整个堆空间的1/4到1/3左右。同时较小的新生代会使得mirror gc次数提升，影响性能。
        
        
        在hot spot虚拟机中，一般使用"-XX:NewSize"用于设置新生代的初始大小，"-XX:MaxNewSize"用以设置
        新生代的最大值。但通常情况下，设置"-Xmn"就足够了，因为设置-Xmn等同于设置了相同的-XX:NewSize和
        -XX:MaxNewSize。
        
        note: 如果设置了不同的-XX:NewSize和-XX:MaxNewSize，则会引起内存震荡。
        
    设置持久代：
        持久代(方法区)不属于堆的一部分，一般使用"-XX:PermSize"来设置持久代的初始大小。使用-XX:MaxPermSize
        设置持久代的最大值。
        
        该值一般直接决定了系统中可以支持多少个类定义和常量。一般设置MaxPermSize为64M就可以满足大部分系统
        正常工作了。如果依然溢出，可以设置为128M
        
    设置线程栈：
        在JVM中，可以使用"-Xss"来设置线程栈的大小。
        在线程中进行局部变量分配，函数调用时，都会在栈中开辟空间。如果栈的空间分配太小，那么线程在运行时，可能
        没有足够的空间分配局部变量和达不到足够的函数调用深度而导致程序异常退出；如果栈空间过大，则会增加开设
        线程的代价。
        
        
        首先，简单地使用-Xss:1M运行程序的话，即每个线程拥有1M的栈空间，显示共可开设的线程数为2000个，增大-Xss
        的值，使用-Xss:20M,为每个线程分配20M的栈空间，结果。线程数仅支持100个线程。
        
        
    堆的内存比例分配：
        -XX:SurriorRatio是用以设置新生代中，eden区和from space空间的比例关系.
            surriorRatio = eden/from sapce = eden/to space
            
            假如-Xmn10M -XX:SurriorRatio=8。 则代表新生代大小为10M，其中eden区域为8M, from、to各为1M。
            
            -Xmn10M -XX:SurriorRatio=2。则新生代大小为10M，其中eden区域为5M，from、to各为2.5M
            
            
        -XX:NewRatio用来设置新生代和老年代的比例
            newRatio = 老年代/新生代
            假如-XX:NewRatio=2 -Xmx20M -Xms20M的话，因为新生代和老年代的比率为1:2，堆的内存为20M。
            因此新生代为：20 * (1/3) =6M， 老年代为12M左右
            
        -XX:PringGCDetails参数可以打印出堆的实际大小，GC信息等
        
        
    堆分配参数总结：
        -Xms:用以设置初始堆大小
        -Xmx:设置最大堆大小
        -Xss:设置线程栈大小
        -XX:NewSize:设置新生代大小
        -XX:MaxNewSize:设置新生代的最大值
        -XX:NewSizeRatio:设置新生代与老年代的比率关系。newSizeRatio=老年代/新生代
        -XX:SurriorRatio:设置新生代中eden区与from space区域比例关系。surriorRatio = eden/from space = eden/to space
        -XX:PermSize:设置持久代初始值
        -XX:PermSize:设置持久代最大值
       
       
       
#### 垃圾收集基础
    垃圾收集器主要处理的问题：
        1。那些对象需要被回收？
        2。什么时候回收这些对象？
        3。如何回收这些对象？
        
        
    引用计数法：
        引用计数法是一种很古老的垃圾收集方法，它指的是：对于任意一个对象A，只要有任意一个对象引用了A，则A的引用计数器
        就加1，当引用失效时，引用计数减1。只要对象A的引用计数的值为0，则对象A就会被回收。
        
        存在的问题：当2个对象之间互相引用，而没有其他对象引用的时候。2个对象都应该需要被回收的，但是由于互相引用，
        导致引用计数不为0，因此无法被回收。从而引起内存泄漏。因此在Java虚拟机中并没有采用该算法。
        
        
    标记-清除算法：
        标记-清除算法是现代垃圾回收算法的基础。标记-清除算法分为2个阶段：标记阶段和清除阶段。
        在标记阶段，首先通过根结点，标记所有从根结点开始的可达对象。因此，未被标记的对象就是没有被引用的垃圾对象，
        之后，在清除阶段，清除所有未被标记的对象。(系统回收所有不可达的空间)
        
        存在的问题：清除阶段后产生空间碎片。该算法的缺点是回收后的空间是不连续的。在对象的分配过程中，尤其是大对象
        的内存分配，不连续的空间效率低于连续的内存空间。
        
        
    复制算法：
        与标记-清除算法相比，复制算法效率比较高。它的核心思想是：将内存空间划分为2块区域。每次只是用一块，
        在垃圾回收时，将正在使用的内存块中的存活对象复制到另外一块内存空间中，然后清除正在使用的内存块中的垃圾对象，
        然后交换2个内存块的角色，完成垃圾回收。
        
        优点：如果系统中的垃圾对象很多，复制算法需要复制的存活对象并不会很多，因此，在复制算法的效率是很高的。
            又因为存活对象是统一被复制到另一块内存中的，所以不会产生空间碎片。
            
        缺点：虽然复制算法的效率高和不会产生空间碎片，但是需要额外的内存空间，需要将内存空间折半。因此，单纯的
        复制算法是不能接受的。
        
        
        应用：在Java新生代的内存空间中，采用了复制算法的思想。新生代空间分为eden区域、from和to区域3个部分。
            其中from和to空间可以看错2块大小相同、地位相等的内存空间。surrior空间用以存放未被回收的对象。
            
            在垃圾回收时(mirror gc)，eden区域存活的对象会被复制到未使用的surrior空间(假如是to空间)，
            正在使用的surrior空间(假如是from)中的年轻的存活对象也会被复制到to空间(其中大对象和老年代对象
            会直接进入老年代)。此时，eden区域和from区域剩余的都是垃圾对象，可以直接回收。回收完成后，交换from和
            to空间的角色。完成垃圾回收。
            
            这种改进的复制算法，即保证了空间的连续性，又避免了内存空间的浪费。
            
            复制算法比较适用于新生代中，因为在新生代中，垃圾对象通常多余存活对象。复制算法的效果会比较好。
            
            
            
    标记-压缩算法：
        复制算法的高效是建立在垃圾对象多，存活对象少的基础上的，新生代就很适合。而对于老年代的情况则相反：垃圾
        对象少、存活对象多。因此复制算法也就不适应了。
        
        标记-压缩算法是一种老年代的垃圾回收算法，它是在标记-清除算法的基础上进行改进的。
        
        和标记-清除算法一样，在标记阶段，通过根结点标记所有的可达对象。但之后，它并不直接清理垃圾对象，而是
        将所有的存活对象压缩到内存的一端。然后，清理边界后的所有垃圾对象。这种方法避免了空间碎片的产生，也不需要
        额外的内存空间。因此是非常适合老年代的垃圾回收算法。
        
        
    分代：
        前面介绍的算法中，并没有一种算法可以完全替代其他的算法。因此Java虚拟机采用了一种分代、自适应的思想。
        
        分代的思想是，将内存空间分为几块区域，不同的区域使用不同的垃圾回收算法。
           以Hot Spot虚拟机为例，他将所有的新对象放到新生代的内存区域，新生代的特点是对象朝生夕灭，容易产生
           大量垃圾对象，因此适合复制算法。当一个对象经历过多次回收后仍然存活，它会进入老年代的内存区域，老年代的
           特点是极少的垃圾对象，因此是不适合采用复制算法的。因此老年代采用了标记-压缩的算法，以提高垃圾回收的效率。
           
#### 堆内存溢出（outOfMemoryError：java heap space）
    
       在jvm规范中，堆中的内存是用来生成对象实例和数组的。

       如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。

       当生成新对象时，内存的申请过程如下：

          a、jvm先尝试在eden区分配新建对象所需的内存；

          b、如果内存大小足够，申请结束，否则下一步；

          c、jvm启动youngGC，试图将eden区中不活跃的对象释放掉，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；

          d、Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区；

          e、 当OLD区空间不够时，JVM会在OLD区进行full GC；

          f、full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”。
          
#### JVM调优案例和方法？ 

    新对象预留在新生代：
          因为Full GC的成本远大于mirror gc，所以将对象分配在新生代能较少full gc的次数。因此，jvm调优时，
          应当合理的分配新生代的大小，避免对象直接进入老年代。
          
          可以通过使用参数-Xmn和-XX:NewRatio来分配新生代的大小。
          
          通过设置一个较大的新生代预留新对象，设置合理的surrior大小并且提高surrior的利用率，可以将年轻对象
          保存在年轻代。当surrior区域不够或者占用量达到50%时，对象就会进入老年代(无论对象的年龄有多大)。
          
          因此设置合理的surrior空间和提升利用率可以有效地把年轻对象预留在新生代。
          
          可以使用-XX:SurriorRatio来设置surrior空间大小
          使用-XX:TargetSurriorRatio来设置surrior空间的利用率
          
    
    大对象进入老年代：
          大部分情况下，将新生对象预留在新生代是合理的。但对于大对象来说则是不适应的，因为大对象出生在新生代
          容易干扰新生代的gc，因为在分配空间给大对象的时候，很有可能空间不足，因此不得不把一些年轻对象摞到老年代
          中，因为老年代的空间大，所以，可能需要移动大量的年轻对象，这对gc来说是相当不利的。
          
          因此，可以将大对象直接进入老年代，保证新生代结构的完整性，以提高gc效率。但是这是对于长命的老年代对象来说的，
          如果大对象的寿命短，并且出现的情况较为频繁，那么对于gc来说会是一种灾难。老年代中存放大量的短命大对象，
          势必会引起频繁的full gc。因此开发过程中，不要出现短命的大对象。
          
          可以使用-XX:PreTenuredSizeThread设置大对象进入老年代的阈值。
          
    设置对象进入老年代的年龄:
        堆中的每个对象都是有年龄了。如果对象在eden区域，经历一次gc还存活的话，会被移入到surrior空间，并且
        对象年龄加1。以后没经历过一次gc还存活，年龄加1。超过设置的阈值的话对象进入老年代。
        
        默认的阈值为15，我们可以通过参数-XX:MaxTenuredingThreshold来设置该阈值。
        
        
    稳定堆：
        一般来说，稳定的堆大小对你垃圾回收是有利的。获取稳定的堆一般是使得最大堆和最小堆保持一致。
        
        
#### 内部类和静态内部类的区别？
    从字面上看，一个被称为静态嵌套类，一个被称为内部类。从字面的角度解释是这样的：什么是嵌套？
    嵌套就是我跟你没关系，自己可以完全独立存在，但是我就想借你的壳用一下，来隐藏一下我自己（真TM猥琐）。
    什么是内部？内部就是我是你的一部分，我了解你，我知道你的全部，没有你就没有我。（所以内部类对象是以
    外部类对象存在为前提的）
    
    
    
#### Redis和MemCached：什么时候选择redis，什么时候选择MemCached，内存模型和存储策略是什么样的？
    
#### MySQL的基本操作 主从数据库一致性维护

#### mysql的优化策略有哪些

#### mysql索引的实现 B+树的实现原理

#### 什么情况索引不会命中，会造成全表扫描

#### java中bio nio aio的区别和联系
    BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流
    或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码
    比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。
    
    NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用
    的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。
    
    AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO
    （Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，
    当后台处理完成，操作系统会通知相应的线程进行后续的操作。
#### 为什么bio是阻塞的 nio是非阻塞的 nio是模型是什么样的
    
    阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。
    调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。还是上面的例子，
    你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的
    结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有
    没有返回结果。
    
#### Java io的整体架构和使用的设计模式

#### Reactor模型和Proactor模型


#### http请求报文结构和内容？
    
#### tcp三次握手和四次挥手？


#### 缓存和数据库一致性同步解决方案?
    数据库更新数据完成后，删除缓存。如果删除失败，我们可以通过消息队列来存储该删除指令。
    
    
#### selector的核心？
    selector称之为多路复用器，Java NIO的实现关键是多路复用I/O技术，而多路服用的核心就是通过Selector来轮询
    注册在其上的Channel集合，当某个或多个Channel处于就绪状态时，就从阻塞状态(select()方法)返回处于就绪的Channel的选择健集合，进行IO操作。
    
    非阻塞I/O中1个线程处理N个客户端连接
    
#### 什么是fail-fast？
    fail-fast,其实，这是一种理念，说白了就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报。
    
    例子：
        public int divide(int divisor,int dividend){
            if(dividend == 0){
                throw new RuntimeException("dividend can't be null");
            }
            return divisor/dividend;
        }
     
    上面的代码是一个对两个整数做除法的方法，在divide方法中，我们对被除数做了个简单的检查，如果其值为0，那么就直接抛出一个异常，并明确提示异常原因。这其实就是fail-fast理念的实际应用。
    
    这样做的好处就是可以预先识别出一些错误情况，一方面可以避免执行复杂的其他代码，另外一方面，这种异常情况被识别之后也可以针对性的做一些单独处理。
    
#### 集合类中的fail-fast
    既然，fail-fast是一种比较好的机制，为什么说fail-fast会有坑呢？
    
    原因是Java的集合类中运用了fail-fast机制进行设计，一旦使用不当，触发fail-fast机制设计的代码，就会发生非预期情况。
    
    
    我们通常说的Java中的fail-fast机制，默认指的是Java集合的一种错误检测机制。当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException（后文用CME代替）。
    
    CMException，当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。
    
    很多时候正是因为代码中抛出了CMException，很多程序员就会很困惑，明明自己的代码并没有在多线程环境中执行，为什么会抛出这种并发有关的异常呢？这种情况在什么情况下才会抛出呢？我们就来深入分析一下
    
    深入分析内容请参考： http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/fail-fast-vs-fail-safe
    
    
#### 锁优化的思路
    减少锁持有时间 
    减小锁粒度
    锁分离 
    锁粗化 
    锁消除
    
    1.1 减少锁持有时间
        public synchronized void syncMethod(){  
    		othercode1();  
    		mutextMethod();  
    		othercode2(); 
    	}
    
    像上述代码这样，在进入方法前就要得到锁，其他线程就要在外面等待。
    这里优化的一点在于，要减少其他线程等待的时间，所以，只用在有线程安全要求的程序上加锁
    
        public void syncMethod(){  
    		othercode1();  
    		synchronized(this)
    		{
    			mutextMethod();  
    		}
    		othercode2(); 
    	}
    	
    1.2 减小锁粒度
    
    将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。
    
    最最典型的减小锁粒度的案例就是ConcurrentHashMap。这个在[高并发Java 五] JDK并发包1有提到。
    
    1.3 锁分离
    
    最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发Java 五] JDK并发包1。
    
    读写分离思想可以延伸，只要操作互不影响，锁就可以分离。
    
    比如LinkedBlockingQueue  
    
    1.4 锁粗化
    
    通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，
    应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，凡事都有一个度
    ，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。
    
    举个例子：
        public void demoMethod(){  
    		synchronized(lock){   
    			//do sth.  
    		}  
    		//做其他不需要的同步的工作，但能很快执行完毕  
    		synchronized(lock){   
    			//do sth.  
    		} 
    	}
    
    这种情况，根据锁粗化的思想，应该合并
        public void demoMethod(){  
    		//整合成一次锁请求 
    		synchronized(lock){   
    			//do sth.   
    			//做其他不需要的同步的工作，但能很快执行完毕  
    		}
    	}
    
    当然这是有前提的，前提就是中间的那些不需要同步的工作是很快执行完成的。
    再举一个极端的例子：
    
            for(int i=0;i<CIRCLE;i++){  
    			synchronized(lock){  
    				
    			} 
    		}
    在一个循环内不同得获得锁。虽然JDK内部会对这个代码做些优化，但是还不如直接写成
            synchronized(lock){ 
    			for(int i=0;i<CIRCLE;i++){ 
    				
    			} 
    		}
    当然如果有需求说，这样的循环太久，需要给其他线程不要等待太久，那只能写成上面那种。如果没有这样类似的需求，还是直接写成下面那种比较好。
    
    
    1.5 锁消除
    
    锁消除是在编译器级别的事情。
    
    在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。
    
    也许你会觉得奇怪，既然有些对象不可能被多线程访问，那为什么要加锁呢？写代码时直接不加锁不就好了。
    
    但是有时，这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。
    
    比如：
        public static void main(String args[]) throws InterruptedException {
    		long start = System.currentTimeMillis();
    		for (int i = 0; i < 2000000; i++) {
    			createStringBuffer("JVM", "Diagnosis");
    		}
    		long bufferCost = System.currentTimeMillis() - start;
    		System.out.println("craeteStringBuffer: " + bufferCost + " ms");
    	}
    
    	public static String createStringBuffer(String s1, String s2) {
    		StringBuffer sb = new StringBuffer();
    		sb.append(s1);
    		sb.append(s2);
    		return sb.toString();
    	}
    
    上述代码中的StringBuffer.append是一个同步操作，但是StringBuffer却是一个局部变量，
    并且方法也并没有把StringBuffer返回，所以不可能会有多线程去访问它。
    那么此时StringBuffer中的同步操作就是没有意义的。
    
    开启锁消除是在JVM参数上设置的，当然需要在server模式下：
    
    
    -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks