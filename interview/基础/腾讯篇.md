# Java基础

#### 你对面向对象的理解？
    面向对象，首先要弄懂什么是对象？
    1. 万物皆对象。将对象看错独特的变量，他除了包含数据，还具有行为(方法)。理论上讲，
        我们可以将待求解问题的所有概念抽取为构件(对象，如狗、建筑物、服务等)，将其表示为程序中的对象
    2. 程序是对象的集合，对象之间通过发送消息交流。更具体地说，可以将消息理解为对某个对象的特定
        方法的调用。
    3. 每个对象都可以包含其他对象来创建更复杂的对象--》封装
    4. 每个对象拥有其类型。所有的对象都是唯一的，但同时也是该类(具有相同特性和行为)的一部分。
    5. 某一特定类型的所有对象都可以接收同样的消息。例如圆形可以接收发给几何形类型的消息，这种
<<<<<<< HEAD
        可替代性称之为多态。 
       
#### 什么是多态
    多态指允许不同子类型的对象对同一消息作出不同的响应。（统一操作方法作用于同一个类的不同子类的时候，
    会产生不同的执行结果。）
        
#### 什么是面向对象？
    概述: 将事务高度抽象化的编程模式.
    
    将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。
    
    就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。
=======
        可替代性称之为多态。
>>>>>>> 69e81ebaf5f10d2f02c787dc6e09a6368fd24275

#### 1. JAVA中的几种基本数据类型是什么，各自占用多少字节。
    Java共有8种基本数据类型。分别是byte, short, int, long, float, double, char, boolean
    其中byte、boolean占据1个字节; char, short占据2个字节; int, float占据4个字节; long, double占据4个字节
    数据类型    默认值     取值范围
    byte        0         -2^7 ~ 2^7 -1 
    short       0         -2^15 ~ 2^15 -1
    int         0         -2^31 ~ 2^31 -1
    long        0         -2^63 ~ 2^63 -1
    float       0.0       -2^31 ~ 2^31 -1
    double      0.0       -2^63 ~ 2^63 -1
    char        空         0 ~ 2^16 -1
    boolean     false       true, false
    
#### 2. String类能被继承吗，为什么？
    String不能被继承，因为String类的定义为final。同时String类属于不可变类(类不能被继承， 方法不能被重写， 属性不能更改)
    
#### 3. String，StringBuffer，StringBuilder的区别？
    1. 首先String是不可变类，一旦创建就不能更改；而StringBuffer 和 StringBuilder是可变类，长度可变的。
    2. StringBuffer 和 StringBuilder都继承与AbstractStringBuilder类，且初始化长度都是16， 扩容也是 size << 1 + 2；
    3. String、StringBuffer属于线程安全的; StringBuilder属于线程不安全的。
    
#### 4. ArrayList和LinkedList有什么区别?
    1.两者都继承List<E>接口，但是实现方式不同。ArrayList是基于数组实现的(初始化容量为10， 扩容: 在原基础容量上加上（size() << 1）)，LinkedList是基于循环双向链表实现的。
    2.因为两者的不同底层实现也决定了两者不同功能上的差异性。ArrayList由于数组属性的，因此随机访问速度很快;
    LinkedList由于基于链表实现的，因此随机访问速度相比较于数组实现的ArrayList会慢。
    同时，ArrayList的添加、删除等更改操作会比LinkedList慢很多，因为每次的更改都意味着数组需要重新复制(System.arraycopy)等。
    而LinkedList只需要更改下prev, next即可。
    
    
#### 5. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序
    1. 如果有父类，按顺序初始化父类的静态域；然后初始化子类的静态域
    2. 按顺序初始化父类的实例域，并分配空间，设置默认的初始值
    3. 执行父类的构造函数
    4. 按顺序初始化子类的实例域，并分配空间，设置默认的初始值
    5. 执行子类的构造函数，完成初始化
    
    Note: 静态域只在第一次创建时初始化。
    
#### 6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等？
    用过HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap。
    区别：1. 都继承了Map接口，存储的为键值对。并且key是不重复的。
         2. 除了ConcurrentHashMap, 其他3个都不是线程安全的。
         3. HashMap是无序的，LinkedLHashMap保存了插入记录的顺序，TreeMap默认基于键的升序排序。
         4. HashMap是基于数组 + 链表(当链表元素大于8会转换为红黑素)实现的； LinkedHashMap是在HashMap
         的基础上实现的，且其内部另外维护了一个插入顺序的链表。Node(prev, next)；TreeMap是基于红黑树实现的;
         ConcurrentHashMap是线程安全的，采用了分段锁的技术(jdk1.7->分段锁, 1.8后采用硬件级别的CAS操作)。因此性能比HashTable优越很多.其也是基于数组 + 链表
         实现的，并且当链表元素大于8时，也会进行扩容。
         
            Note: 为何jdk1.8放弃锁分段技术，采用CAS无锁算法，使得性能进一步提升。
            CAS算法；unsafe.compareAndSwapInt(this, valueOffset, expect, update);  
            CAS(Compare And Swap)，意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，
            并返回true，否则不更新，返回false。
         5。他们的扩容策略都是2倍，因为在indexFor()方法是，是键的hashcode与数组的length-1进行与运算。为2的倍数的话能均匀地散列到每个桶上，减少碰撞的几率。
         6.HashMap、LinkedHashMap、ConcurrentHashMap的初始容量都是16， TreeMap为0.
        
#### 7. 线程池参数
    线程池的构造函数参数多达7个，现在我们一一来分析它们对线程池的影响。
    
           corePoolSize：线程池中核心线程数的最大值
    
           maximumPoolSize：线程池中能拥有最多线程数
    
           workQueue：用于缓存任务的阻塞队列
    
           我们现在通过向线程池添加新的任务来说明着三者之间的关系。
    
         （1）如果没有空闲的线程执行该任务且当前运行的线程数少于corePoolSize，则添加新的线程执行该任务。
    
         （2）如果没有空闲的线程执行该任务且当前的线程数等于corePoolSize同时阻塞队列未满，则将任务入队列，而不添加新的线程。
    
         （3）如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于maximumPoolSize，则创建新的线程执行任务。
    
         （4）如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于maximumPoolSize，则根据构造函数中的handler指定的策略来拒绝新的任务。
    
           注意，线程池并没有标记哪个线程是核心线程，哪个是非核心线程，线程池只关心核心线程的数量。
    
           通俗解释，如果把线程池比作一个单位的话，corePoolSize就表示正式工，线程就可以表示一个员工。当我们向单位委派一项工作时，如果单位发现正式工还没招满，
           单位就会招个正式工来完成这项工作。随着我们向这个单位委派的工作增多，即使正式工全部满了，工作还是干不完，那么单位只能按照我们新委派的工作按先后顺序将
           它们找个地方搁置起来，这个地方就是workQueue，等正式工完成了手上的工作，就到这里来取新的任务。如果不巧，年末了，各个部门都向这个单位委派任务，导致
           workQueue已经没有空位置放新的任务，于是单位决定招点临时工吧（临时工：又是我！）。临时工也不是想招多少就找多少，上级部门通过这个单位的maximumPoolSize
           确定了你这个单位的人数的最大值，换句话说最多招maximumPoolSize–corePoolSize个临时工。当然，在线程池中，谁是正式工，谁是临时工是没有区别，完全同工同酬。
    
            keepAliveTime：表示空闲线程的存活时间。
    
            TimeUnitunit：表示keepAliveTime的单位。
    
            为了解释keepAliveTime的作用，我们在上述情况下做一种假设。假设线程池这个单位已经招了些临时工，但新任务没有继续增加，所以随着每个员工忙完手头的工作，
            都来workQueue领取新的任务（看看这个单位的员工多自觉啊）。随着各个员工齐心协力，任务越来越少，员工数没变，那么就必定有闲着没事干的员工。这样的话
            领导不乐意啦，但是又不能轻易fire没事干的员工，因为随时可能有新任务来，于是领导想了个办法，设定了keepAliveTime，当空闲的员工在keepAliveTime
            这段时间还没有找到事情干，就被辞退啦，毕竟地主家也没有余粮啊！当然辞退到corePoolSize个员工时就不再辞退了，领导也不想当光杆司令啊！
    
           handler：表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。
            
           threadFactory：指定创建线程的工厂
           
#### 8.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。
            BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
            
            NIO：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
            
            reactor模型：反应器模式（事件驱动模式）：当一个主体发生改变时，所有的属体都得到通知，类似于观察者模式。
            
#### 9. 反射的原理，反射创建类实例的三种方式是什么。
        原理
        JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，
        都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
        
        静态编译和动态编译
        静态编译：在编译时确定类型，绑定对象
        动态编译：运行时确定类型，绑定对象
        
        反射机制优缺点
        优点： 运行期类型的判断，动态加载类，提高代码灵活度。
        缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。
        反射创建类实例的三种方式
            1、Class.forName(“com.A”)
            2、new A().getClass()    //根据已有对象获取
            3、A.class
            然后class.newInstance()即可创建对象
            
#### 10.反射中，Class.forName和ClassLoader区别 。
        1、class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
        
        2、classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,
        只有在newInstance才会去执行static块。

#### 11.描述动态代理的几种实现方式，分别说出相应的优缺点。
        动态代理有两种实现方式，分别是：jdk动态代理和cglib动态代理。
        
        jdk动态代理的前提是目标类必须实现一个接口，代理对象跟目标类实现一个接口，
        从而避过虚拟机的校验。
        
        cglib动态代理是继承并重写目标类，所以目标类和方法不能被声明成final。

#### 12.为什么CGlib方式可以对接口实现代理。
        cglib动态代理是继承并重写目标类，所以目标类和方法不能被声明成final。而接口是可以被继承的。
        
#### 13. final的用途。
         1、被final修饰的类不可以被继承。
         
         2、被final修饰的方法不可以被重写。
         
         3、被final修饰的变量不可以被改变（final修饰不可变的是变量的引用，而不是引用指向的内容，
         引用指向的内容是可以改变的。）
         
         总结：被final修饰的方法，JVM会尝试为之寻求内联，这对于提升Java的效率是非常重要的。
         因此，假如能确定方法不会被继承，那么尽量将方法定义为final的。

#### 14. 单例模式的几种写法
     饿汉式、懒汉式、双重检验锁、静态内部类、枚举(推荐后2种)
     
#### 15.面向对象的特征有哪些方面?
        答：面向对象的特征主要有以下几个方面：
        -- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象     
            两方面。抽象只关注对象有哪些属性和行为，并不关具体细节是什么。
        -- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类);
            得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承
            也是封装程序中可变因素的重要手段。
        -- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
            面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对
            实现细节的一种封装;我们编写一个类就是对数据和数据操作的封装。可以说，
            封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口(
            可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单;
            我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情)。
        -- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的
            对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。
            方法重载(overload)实现的是编译时的多态性(也称为前绑定)，
            而方法重写(override)实现的是运行时的多态性(也称为后绑定)。
<<<<<<< HEAD
#### 实现多态的三个条件
     
     1。继承的存在。继承是多态的基础，没有继承就没有多态
     2。子类重写父类的方法，JVM 会调用子类重写后的方法
     3。父类引用变量指向子类对象
=======
>>>>>>> 69e81ebaf5f10d2f02c787dc6e09a6368fd24275
            
#### 16. 接口和抽象类有什么区别?
     接口和抽象类都提供了一种使得接口和实现分离的机制。
     语法层面:
        1.抽象类允许子类不实现具体方法，但该子类也必须为抽象类; 而对于接口来说，子类必须实现接口中定义方法。
        2.一个类只能继承一个抽象类，但可以实现多个接口
        3.抽象类、接口(1.8。default)中可以有具体实现，抽象类中的方法实现可以是public、private、default等，接口中只能是default.
            抽象类中的抽象方法权限访问级别必须是public 或protected的；接口中只能是public
        4.抽象类中的变量是没有限制的，接口中的变量默认是public static final
        5.抽象类中可以含有静态代码块和静态方法，而接口中是不允许的
     设计层面：
<<<<<<< HEAD
        首先，接口和抽象类都是对相同事物进行了抽象，只是抽象程度不同。抽象类是对一类相同事物(类型)进行抽象，如鸟类。
=======
        首先，接口和抽象类都是对相同事物进行了抽象，只是抽象程度不同。抽象类是对一类相同事物进行抽象，如鸟类。
>>>>>>> 69e81ebaf5f10d2f02c787dc6e09a6368fd24275
        包括数据抽象和行为抽象。而接口只对行为进行抽象，抽象程度也更高。如飞行这个行为。
   
        1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，
        包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，
        但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，
        将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，
        并不是对一类事物的抽象描述。从这里可以看出，继承是一个 "是不是"的关系，
        而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，
        而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），
        能飞行则可以实现这个接口，不能飞行就不实现这个接口。
        
        2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，
        它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用
        模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分
        需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，
        比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，
        如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；
        而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
        
        
#### 17. 深拷贝和浅拷贝区别。
<<<<<<< HEAD
      浅拷贝只拷贝引用(地址)，深拷贝就是拷贝引用指向对象的内容，重新生成的对象。
      
#### 18. 同步和异步的区别
    同步和异步是相对于被调用方来说的。
    
    比如A调用B，如果B立刻执行A的请求，则是同步的。如果B告诉A，我收到你的请求了，但是我现在不会执行，等我有时间再去处理，处理
    完成后会通知你。
    
    更准确的定义：
    
    同步和异步是针对应用程序和内核的交互而言的。
    
    同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。例如：自己上街买衣服，自己亲自干这件事，别的事干不了。
    
    异步指的是用户进程触发IO操作以后便开始做其他的事情，而当IO操作已经完成的时候会得到IO完成的通知。
    例如：告诉朋友自己合适衣服的尺寸、颜色、款式，委托朋友去买，然后自己可以去干别的事。同时，你还需要告诉朋友你家衣柜在哪，
    方便朋友买完之后，直接将衣服放到你的衣柜。（使用异步I/O时，Java将I/O读写委托给OS处理，需要将数据缓冲区地址和大小传给OS）。

#### 19. 阻塞和非阻塞的区别
    阻塞和非阻塞是相对于调用方来说的。
    
    比如A调用B， 如果A调用B，如果A进行等待结果返回的话，则是阻塞。如果A不进行等待，转身去做其他事，等待B通知回调后再处理，则是
    非阻塞。
    
    同步不一定阻塞。但是异步一定是非阻塞的
      
      
    阻塞和非阻塞是针对进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式。
    
    阻塞指的是当试图对该文件描述符进行读写时，如果当时没有东西可读，或暂时不可写，程序就进入等待状态，直到有东西可读或可写为止。
    去地铁站充值，发现这个时候充值员碰巧不在，然后我们就在原地等待，一直等到充值员回来为止。
    
    非阻塞指的是如果没有东西可读，或不可写，读写函数马上返回，而不会等待。在银行里办业务时，领取一张小票，之后我们可以玩手机，
    或与别人聊聊天，当轮到我们时，银行的喇叭会通知，这时候我们就可以去办业务了。
=======
      浅拷贝只拷贝引用(地址)，深拷贝就是拷贝引用指向对象的内容，重新生成的对像。
      
      
>>>>>>> 69e81ebaf5f10d2f02c787dc6e09a6368fd24275
